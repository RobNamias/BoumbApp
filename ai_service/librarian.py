import asyncio
import argparse
import os
import logging
from rag_pipeline.perplexity_client import PerplexityClient

# Configure Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("Librarian-CLI")

def update_category_index(category_dir: str):
    """
    Generates an index.md file listing all markdown files in the directory (recursive).
    """
    if not os.path.exists(category_dir):
        return

    category_name = os.path.basename(category_dir).capitalize()
    
    indexed_files = []
    
    # Recursive walk
    for root, dirs, files in os.walk(category_dir):
        for file in files:
            if file.endswith(".md") and file != "index.md" and file != "glossaire.md":
                full_path = os.path.join(root, file)
                # Calculate relative path from category_dir for the link
                rel_path = os.path.relpath(full_path, category_dir).replace("\\", "/")
                
                # Create readable title from filename (funk_bass.md -> Funk Bass)
                title = file.replace(".md", "").replace("_", " ").title()
                
                # If in subdirectory, prepend subfolder name to title for clarity? 
                # e.g. "Acidcore - Classic Melody"
                # Let's keep it simple for now, maybe add (Category) suffix if needed, 
                # but unique filenames are better. For now just Title.
                
                indexed_files.append((title, rel_path))
    
    # Sort by title
    indexed_files.sort(key=lambda x: x[0])
    
    index_path = os.path.join(category_dir, "index.md")
    
    with open(index_path, "w", encoding="utf-8") as f:
        f.write(f"# Index: {category_name}\n\n")
        f.write("> Auto-generated by Librarian (Recursive)\n\n")
        
        # Group by folder maybe? Or just flat list?
        # A flat list is easier for now as per the request "risquent d'√™tre incomplets".
        for title, rel_path in indexed_files:
            f.write(f"- [{title}]({rel_path})\n")
            
    logger.info(f"üìë Index updated (Recursive): {index_path}")

async def search_and_catalogue(topic: str, category: str): # Renamed wrapper
    """
    Main sequence: Search Perplexity -> Save Markdown.
    """
    client = PerplexityClient()
    filepath = await fetch_and_store(client, topic, category)
    
    # Define output_dir from filepath
    output_dir = os.path.dirname(filepath)
    
    # 3. Update Index
    update_category_index(output_dir)
    
    # 4. Update Global Glossary
    # Handling edge case if directory structure is deeper or simpler
    # Assuming standard knowledge_base/category structure
    glossary_path = os.path.join("knowledge_base", "glossaire.md") 
    
    # Simple Append (Avoid duplicates logic could be added but explicit append is faster for now)
    # We use a relative link from the root KB
    rel_path = os.path.join(os.path.basename(output_dir), os.path.basename(filepath)).replace("\\", "/")
    
    try:
        glossary_entry = f"- **{topic}**: [{rel_path}]({rel_path})\n"
        await async_write(glossary_path, glossary_entry, mode="a")
        logger.info(f"üìñ Glossary updated: {topic}")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Could not update glossary: {e}")

def main():
    parser = argparse.ArgumentParser(description="The Librarian: Hybrid RAG Knowledge Builder")
    parser.add_argument("topic", type=str, help="The musical topic to research (e.g. 'Funk Bass', 'Lo-Fi Hip Hop')")
    parser.add_argument("--category", type=str, default="styles", choices=["styles", "theory", "instruments", "tags", "synth_settings"], help="Category subfolder")
    parser.add_argument("--out", type=str, default="knowledge_base", help="Root directory for Knowledge Base")

    args = parser.parse_args()
    
    # Append category to output path
    full_output_dir = os.path.join(args.out, args.category)
    
    # Run Async
    asyncio.run(search_and_catalogue(args.topic, full_output_dir))

if __name__ == "__main__":
    main()
